1. Initialize deck
2. Deal cards to player and dealer
3. Player turn: hit or stay
  - repeat until bust or "stay"
4. If player bust, dealer wins.
5. Dealer turn: hit or stay
  - repeat until total >= 17
6. If dealer bust, player wins.
7. Compare cards and declare winner.


HARD_ACE = 1
ACE = HARD_ACE + 10
Soft Hand: Hand with an Ace that doubles as 1 or 11. There is no way you can bust if you hit.
SOFT_HAND


Soft Total: The total of any number of cards in a hand, which includes an Ace which can use it’s 11 value, without exceeding 21. 
  - Ex. Hand: Ace, 4. This hand’s Soft Total would be 15. It can also be counted as a Hard 5.

soft_total =

Soft Total - any hand containing an ace which has a value of 11.

Bust: When a player’s or dealer’s hand exceeds 21.
BUST = 

Bust Card: The individual card that results in the player’s or dealer’s hand going over 21.
bust_card = 


Hard Hand: Hand without an Ace, or with an Ace but only as a value of 1.
hand_value = 10
=> 10
HARD_HAND = HARD_ACE + hand_value
=> 11
HARD_HAND
=> 11



Hard Total: The total of any number of cards in a hand, counting Aces as 1.
HARD_TOTAL = card_value + HARD_ACE

Hit: This playing decision will require the dealer to deal another card onto the player’s Blackjack hand.
def hit(caution - user might be dealer or player)

Natural (blackjack hand): A player who receives an Ace and a 10-point card as the initial two cards on a deal is said to have a “natural 21” or a “blackjack”. Depending on the house rules, this hand is usually awarded 3:2 on the player’s bet. I.e. Player bets $10 and is paid $15.
NATURAL = 


Round: In Blackjack, a Round starts with no cards on the table, and the player’s bets being placed. A hand is dealt to every player, and the dealer, and the Round ends when those hands have been played through, and the player’s bets have been paid out.
ROUND = 

Stand: This playing decision will refuse the dealer from dealing another card onto the player’s Blackjack hand.
stand = break

Cut Card: A plastic card used to cut the deck after shuffling. The dealer reshuffles the deck after reaching the cut card when dealing hands.
CUT_CARD = 

Dealer - the casino employee, facing the players, who deals the cards at the table.

DEALER = 



 deal Hand - the original cards dealt to each player.
original_hand

Push - a tie between the dealer and the player, no one wins or loses.
PUSH = 


Shuffle - mixing up the cards before dealing them.
def shuffle(deck)

Stiff Card - a card ranked from 2 to 6, which may force the dealer to hit.
STIFF_CARD = 

Stiff Hand - any hand totalling 12-16, which will bust on a 10-value card hit.
STIFF_HAND

Ten-Value Card - any card worth 10 points, a 10, Jack, Queen, or King.
TEN_VALUE_CARD


Upcard - the dealer's exposed card, seen by all players.
upcard = 

downcard

Face Cards: Face Cards are cards which have pictures on them. These include jacks, queens and kings. In each deck of cards, you’ll find that there are 4 of each present.
starting number of face cards
jacks = 4 = jack - 1 
king = 4
queen = 4

JACK = 10
KING = 10
QUEEN = 10




Standing Hand: A ‘standing hand’ is one in which the player has a total hand value of 17 and higher. In this case, it is not considered wise to take another card.
STANDING_HAND = value >= 17

Stiff Hand: A ‘stiff hand’ is a hand which is not ranked as a great hand. Typically, the total score of the hand in this case is quite low, so you in hindsight the player does not have much of a chance to winning. Nonetheless, if the player chooses to hit, he/she might bust as a result.
STIFF_HAND = hand_value > 9


deck start with a normal 52-card deck consisting of the 4 suits (hearts, diamonds, clubs, and spades), and 13 values (2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king, ace).
can a constant be = the values of other constants
deck = 52 or deck = jacks + kings + queens

Starting deck number
or deck not constant like board

dealer \
          later they will probablly make the game switch choose who is the dealer
player /


DEALER_TURN
PLAYER_TURN


DEALER_BREAK
PLAYER_BREAK





Stand 17 (s17): A rule in blackjack that requires the dealer to stand when sitting on a Soft 17. Compare this rule to Hit 17, which requires the dealer to hit when sitting on a Soft 17.

GAME_TYPE = STAND_SEVENTEEN
GAME_TYPE = HIT_SEVENTEEN
Here’s more information on the difference between Stand 17 and Hit 17.

HARD_SEVENTEEN
SOFT_SEVENTEEN











When you display the results, you also need to perform the calculation of who won. Having one method that does both the calculation and the display to the output makes it hard to reason about. The trick is to create a method that only returns the result of the game, and another that only handles displaying the result. You want to write methods that only do one thing.






1. Initialize deck
2. Deal cards to player and dealer
3. Player turn: hit or stay
  - repeat until bust or "stay"
4. If player bust, dealer wins.
5. Dealer turn: hit or stay
  - repeat until total >= 17
6. If dealer bust, player wins.
7. Compare cards and declare winner.



Figure out a data structure to contain the "deck" and the "player's cards" and "dealer's cards". Maybe a hash? An array? A nested array? Your decision will have consequences throughout your code, but don't be afraid of choosing the wrong one. Play around with an idea, and see how far you can push it. If it doesn't work, back out of it.

You start with a normal 52-card deck consisting of the 4 suits (hearts, diamonds, clubs, and spades), and 13 values (2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king, ace).

```ruby

deck 
  - starts with 52 cards
    - 4 jacks
    - 4 kings
    - 4 queens

jack = 10
king = 10
queen = 10
ace = 1


hearts, diamonds, clubs, and spades)
deck ={ hearts => [2,3,4,5,6,7,8,9,10, jack, king, queen, ace]   } 

deck[hearts][two]
=> 2

hearts = [2,3,4,5,6,7,8,9,10, jack, king, queen, ace]


deck -=  dealt_card heart[jack] => 10
                    heart[king] => 10
                    heart[face_value] => 4 

iterate through deck.sample

dealer_hand += dealt_card

player_hand += dealt_card



display the players deck

display the dealers first card

deal

King 
Ace of Hearts: 

2 of Hearts: 

3 of Hearts: 

4 of Hearts: 

5 of Hearts: 

6 of Hearts: 

7 of Hearts:

8 of Hearts: 
9 of Hearts: 

10 of Hearts: 

Jack of Hearts: 

Queen of Hearts: 

King of Hearts: 



5 of Hearts
2 of Hearts:



SUITS = ["hearts", "diamonds", "clubs", "spades" ]
suit_values = [2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king, ace]

deck = [hearts, diamonds, clubs,spades ]

deck.sample
  => hearts



diamonds = {"diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"] }
hearts = {"hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"] }
clubs = {"clubs" => [] }
spades = {"spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"] }


def select_card
 suit = SUITS.sample
 "hearts"




deck = {
        "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "clubs" => [],
        "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]
        } 






deck = {
  "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],        
  "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],        
  "clubs" => [],        
  "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]        
}           



suits = ["hearts", "diamonds", "clubs", "spades"]














def suit? suits
  suits.sample
end  

def card_value?(deck, suits)
  deck[suits?].sample
end  

def remove_card! deck, suit, card
  deck[suit].delete(card)
end  

def suit_empty?(suit, deck)
  deck[suit].empty?
end  

def remove_suit(deck, suit)
  deck.delete(suit)
end 


PAINTED_CARD_VALUE = 10

deck = {"diamonds"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "hearts"=>[2, 3, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "clubs"=>[2],
 "spades"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]}

suits = ["hearts", "diamonds", "clubs", "spades"]

suit = "clubs"
=> "clubs"




def deal(suits, deck)

suit = suit? suits
=> "clubs"
suit = clubs



card = card_value? deck, suit
=> 2


remove_card! deck, suit, card
=> 2
deck
=> {"diamonds"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "hearts"=>[2, 3, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "clubs"=>[],
 "spades"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]}




suit_empty? suit, deck
=> true

remove_suit(deck, suit)  if suit_empty? suit, deck
=> []
deck
=> {"diamonds"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "hearts"=>[2, 3, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "spades"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]}





PAINTED_CARD_VALUE = 10



deck = {
        "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "clubs" => [],
        "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]
        } 

suits = ["hearts", "diamonds", "clubs", "spades"]

def deal(suits,deck)
suit = suit? suits
card = card_value? deck, suit
remove_card! deck, suit, card
suit_empty? suits, deck
remove_suit(deck, suits)  if suit_empty? suits, deck
card 
card == Integer ? card : card = PAINTED_CARD_VALUE
[suit,card]
end





card = ace

later assign HARD_ACE or SOFT_ACE

**************************************************************************************************************************************************************************************************

DEAL A CARD 
REMOVE THE DEALT CARD FROM THE DECK 
REMOVE THE SUIT FROM THE DECK IF THE LAST CARD OF THAT SUIT HAS BEEN DEALT
RETURN AN ARRAY WITH THE SUIT AND THE CARD VALUE 
PRINT THE VALUE OF THE CARD TO THE SCREEN
INITIALIZE AN EMPTY PLAYERS HAND 
APPEND THE DEALT CARD TO THE PLAYERS HAND 


PAINTED_CARD_VALUE = 10

def suit? suits
  suits.sample
end  

def card_value?(deck, suits)
  deck[suits].sample
end  

def remove_card! deck, suit, card
  deck[suit].delete(card)
end  

def suit_empty?(suit, deck)
  deck[suit].empty?
end  

def remove_suit(deck, suit)
  deck.delete(suit)
end 

deck = {
        "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "clubs" => [],
        "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]
        } 

suits = ["hearts", "diamonds", "clubs", "spades"]

def deal_card(suits,deck)
  binding.pry
suit = suit? suits
card = card_value? deck, suit
remove_card! deck, suit, card
suit_empty? suit, deck
remove_suit(deck, suits)  if suit_empty? suit, deck
card 
card == Integer ? card : card = PAINTED_CARD_VALUE
[card,suit]
end
# => [ 10, "diamonds"]

dealt_card = deal_card suits, deck
# => [ 10, "diamonds"]

puts "#{dealt_card[0]} of #{dealt_card[1]}"
10 of diamonds



players_hand = []

players_hand << dealt_card

players_hand 
# => [[ 10, "diamonds"]]

**************************************************************************************************************************************************************************************************

Well be using a nested array, where each array element is itself a 2-element 
array that represents the cards suit and the cards value, respectively. 
For example, a hand that contains 2 of Hearts, Jack of Spades, 
and Ace of Diamonds could be represented as a nested array like this:

for ls 

deal_card(suits,deck)
...
[card.to_s,suit]
end
# => [ "10", "diamonds"]

[['H', '2'], ['S', 'J'], ['D', 'A']]

**************************************************************************************************************************************************************************************************


Calculating Aces. Remember that aces can be worth either 1 or 11, depending on the context. 
You should not ask the user what the value of the ace is; your program should be able to 
figure this out automatically

if the player gets an ace that is 11
  then aks for a hit and that is 10 then what
  asks for a hit and the value is 10 then asks for another hit the ace is hard at 1
  asks for a hit at 20 the ace is soft????? 


I am the dealer
in real life when a player gets hit and get an ace as the dealer I dont know what it is until 
  the player wins
  the player busts 
  I win 

  deal a card 

  Ace is soft up to 20
  at 21 the ace is hard 

  ace is soft until the sum of the cards is greater than 10
  5, 5 + ace player wins
  6,5 + ace ace is soft

  ace is hard 1 , up to other cards sum <= 10
  ace is soft 11 after sum of cards is > 10

I need to know the value of the ace so I can calculate the players score


count ace as soft  while the player is asking for a hit until the total of cards is over 21 and the player has not said bust

ace 2,9 21
ace 2 10 not busted hit ace is hard


count ace as soft until 

Soft Hand: Hand with an Ace that doubles as 1 or 11. There is no way you can bust if you hit.

Soft Total: The total of any number of cards in a hand, which includes an Ace which can use it’s 11 value, without exceeding 21. 
  Ex. Hand: Ace, 4. This hand’s Soft Total would be 15. It can also be counted as a Hard 5.



Hard Hand: Hand without an Ace, or with an Ace but only as a value of 1.

Hard Total: The total of any number of cards in a hand, counting Aces as 1.



[hard_ace 1 soft_ace 11]

if ace in players_hand and player hits until  card_values.reduce 
when players_hand.reduce > => 21 and player not bust or wins
    ace = hard
when playershand.reduce > 21 and player bust
  ace is 11

**************************************************************************************************************************************************************************************************
CALCULATE TOTAL


card =["", 'ace']

ACE = 


players_hand = [[ "10", "diamonds"][ "8", "diamonds"]]
dealers_hand

          players_hand
def total(hand)
  # players_hand =  [[ "10", "diamonds"][ "8", "diamonds"]]
  # cards = [['H', '3'], ['S', 'Q'], ... ]
  values = cards.map { |card| card[1] }

  
  sum = 0
  values.each do |value|
    if value == "A" # "ACE"
      sum += 11
    elsif value.to_i == 0 # J, Q, K 
      sum += 10 
    else
      sum += value.to_i
    end
  end

  # correct for Aces
  values.select { |value| value == "A" }.count.times do
    sum -= 10 if sum > 21
  end

  sum
end
=> integer value of player_hand or dealer_hand

players_hand_value = total(players_hand)
dealers_hand_value = total(players_hand)

**************************************************************************************************************************************************************************************************
DETERMINE IF THE PLAYER OR DEALER IS BUSTED


def busted?(hand)
  hand > 21
end


players_hand_value = total(players_hand)
dealers_hand_value = total(players_hand)


players_hand_value = 21
busted? players_hand_value
=> false


players_hand_value = 22
busted? players_hand_value
=> true


**************************************************************************************************************************************************************************************************
PLAYERS TURN 


1. ask "hit" or "stay"
if busted break
2. if "stay", stop asking
3. otherwise, go to #1


def player_turn(suits, deck)

  answer = nil
  loop do
    puts player_hand
    puts players_hand_value
    puts "hit or stay?"
    answer = gets.chomp
    break if answer == 'stay' || busted?(players_hand)   # the busted? method is not shown

  else deal_card(suits, deck)
  end

  if busted?(players_hand)
    # probably end the game? or ask the user to play again?
  else
    puts "You chose to stay!"  # if player didn't bust, must have stayed to get here
  end




players_hand = []

players_hand << dealt_card

players_hand 
# => [[ 10, "diamonds"]]


**************************************************************************************************************************************************************************************************

DALERS TURN 



 break if player busted?(players_hand) || dealer busted?(dealers_hand)
 answer = nil
  loop do
    puts dealers_hand
    puts dealers_hand_value
    puts "hit or stay?"
    answer = gets.chomp
    break if answer == 'stay' || busted?   # the busted? method is not shown

  else deal_card(suits, deck)
  end

  if busted?(dealers_hand)
    # probably end the game? or ask the user to play again?
  else
    puts "You chose to stay!"  # if player didn't bust, must have stayed to get here
  end



dealers_hand = []

dealers_hand << dealt_card

dealers_hand 


final_dealer_value

=> integer 18
=> "busted" .class == String



**************************************************************************************************************************************************************************************************
CALCULATE THE WINNER

player stays
  => 15

dealer stays
  => 18

dealer wins 


player busts  => dealer wins

dealer busts => player wins

who_won? final_dealer_value, final_player_value

def who_won?(dealer,player)
  if dealer == "bust"
    return  "player"
  elsif player == "bust"
    return  "dealer"
  end
  dealer > player? "dealer" : "player"
end


=> "dealer"



**************************************************************************************************************************************************************************************************
DISPLAY WINNER 
  puts whow_won
end






