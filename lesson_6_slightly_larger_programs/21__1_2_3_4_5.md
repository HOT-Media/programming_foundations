1. Initialize deck
2. Deal cards to player and dealer
3. Player turn: hit or stay
  - repeat until bust or "stay"
4. If player bust, dealer wins.
5. Dealer turn: hit or stay
  - repeat until total >= 17
6. If dealer bust, player wins.
7. Compare cards and declare winner.


HARD_ACE = 1
ACE = HARD_ACE + 10
Soft Hand: Hand with an Ace that doubles as 1 or 11. There is no way you can bust if you hit.
SOFT_HAND


Soft Total: The total of any number of cards in a hand, which includes an Ace which can use it’s 11 value, without exceeding 21. 
  - Ex. Hand: Ace, 4. This hand’s Soft Total would be 15. It can also be counted as a Hard 5.

soft_total =

Soft Total - any hand containing an ace which has a value of 11.

Bust: When a player’s or dealer’s hand exceeds 21.
BUST = 

Bust Card: The individual card that results in the player’s or dealer’s hand going over 21.
bust_card = 


Hard Hand: Hand without an Ace, or with an Ace but only as a value of 1.
hand_value = 10
=> 10
HARD_HAND = HARD_ACE + hand_value
=> 11
HARD_HAND
=> 11



Hard Total: The total of any number of cards in a hand, counting Aces as 1.
HARD_TOTAL = card_value + HARD_ACE

Hit: This playing decision will require the dealer to deal another card onto the player’s Blackjack hand.
def hit(caution - user might be dealer or player)

Natural (blackjack hand): A player who receives an Ace and a 10-point card as the initial two cards on a deal is said to have a “natural 21” or a “blackjack”. Depending on the house rules, this hand is usually awarded 3:2 on the player’s bet. I.e. Player bets $10 and is paid $15.
NATURAL = 


Round: In Blackjack, a Round starts with no cards on the table, and the player’s bets being placed. A hand is dealt to every player, and the dealer, and the Round ends when those hands have been played through, and the player’s bets have been paid out.
ROUND = 

Stand: This playing decision will refuse the dealer from dealing another card onto the player’s Blackjack hand.
stand = break

Cut Card: A plastic card used to cut the deck after shuffling. The dealer reshuffles the deck after reaching the cut card when dealing hands.
CUT_CARD = 

Dealer - the casino employee, facing the players, who deals the cards at the table.

DEALER = 



 deal Hand - the original cards dealt to each player.
original_hand

Push - a tie between the dealer and the player, no one wins or loses.
PUSH = 


Shuffle - mixing up the cards before dealing them.
def shuffle(deck)

Stiff Card - a card ranked from 2 to 6, which may force the dealer to hit.
STIFF_CARD = 

Stiff Hand - any hand totalling 12-16, which will bust on a 10-value card hit.
STIFF_HAND

Ten-Value Card - any card worth 10 points, a 10, Jack, Queen, or King.
TEN_VALUE_CARD


Upcard - the dealer's exposed card, seen by all players.
upcard = 

downcard

Face Cards: Face Cards are cards which have pictures on them. These include jacks, queens and kings. In each deck of cards, you’ll find that there are 4 of each present.
starting number of face cards
jacks = 4 = jack - 1 
king = 4
queen = 4

JACK = 10
KING = 10
QUEEN = 10




Standing Hand: A ‘standing hand’ is one in which the player has a total hand value of 17 and higher. In this case, it is not considered wise to take another card.
STANDING_HAND = value >= 17

Stiff Hand: A ‘stiff hand’ is a hand which is not ranked as a great hand. Typically, the total score of the hand in this case is quite low, so you in hindsight the player does not have much of a chance to winning. Nonetheless, if the player chooses to hit, he/she might bust as a result.
STIFF_HAND = hand_value > 9


deck start with a normal 52-card deck consisting of the 4 suits (hearts, diamonds, clubs, and spades), and 13 values (2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king, ace).
can a constant be = the values of other constants
deck = 52 or deck = jacks + kings + queens

Starting deck number
or deck not constant like board

dealer \
          later they will probablly make the game switch choose who is the dealer
player /


DEALER_TURN
PLAYER_TURN


DEALER_BREAK
PLAYER_BREAK





Stand 17 (s17): A rule in blackjack that requires the dealer to stand when sitting on a Soft 17. Compare this rule to Hit 17, which requires the dealer to hit when sitting on a Soft 17.

GAME_TYPE = STAND_SEVENTEEN
GAME_TYPE = HIT_SEVENTEEN
Here’s more information on the difference between Stand 17 and Hit 17.

HARD_SEVENTEEN
SOFT_SEVENTEEN











When you display the results, you also need to perform the calculation of who won. Having one method that does both the calculation and the display to the output makes it hard to reason about. The trick is to create a method that only returns the result of the game, and another that only handles displaying the result. You want to write methods that only do one thing.






1. Initialize deck
2. Deal cards to player and dealer
3. Player turn: hit or stay
  - repeat until bust or "stay"
4. If player bust, dealer wins.
5. Dealer turn: hit or stay
  - repeat until total >= 17
6. If dealer bust, player wins.
7. Compare cards and declare winner.



Figure out a data structure to contain the "deck" and the "player's cards" and "dealer's cards". Maybe a hash? An array? A nested array? Your decision will have consequences throughout your code, but don't be afraid of choosing the wrong one. Play around with an idea, and see how far you can push it. If it doesn't work, back out of it.

You start with a normal 52-card deck consisting of the 4 suits (hearts, diamonds, clubs, and spades), and 13 values (2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king, ace).

```ruby

deck 
  - starts with 52 cards
    - 4 jacks
    - 4 kings
    - 4 queens

jack = 10
king = 10
queen = 10
ace = 1


hearts, diamonds, clubs, and spades)
deck ={ hearts => [2,3,4,5,6,7,8,9,10, jack, king, queen, ace]   } 

deck[hearts][two]
=> 2

hearts = [2,3,4,5,6,7,8,9,10, jack, king, queen, ace]


deck -=  dealt_card heart[jack] => 10
                    heart[king] => 10
                    heart[face_value] => 4 

iterate through deck.sample

dealer_hand += dealt_card

player_hand += dealt_card



display the players deck

display the dealers first card

deal

King 
Ace of Hearts: 

2 of Hearts: 

3 of Hearts: 

4 of Hearts: 

5 of Hearts: 

6 of Hearts: 

7 of Hearts:

8 of Hearts: 
9 of Hearts: 

10 of Hearts: 

Jack of Hearts: 

Queen of Hearts: 

King of Hearts: 



5 of Hearts
2 of Hearts:



SUITS = ["hearts", "diamonds", "clubs", "spades" ]
suit_values = [2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king, ace]

deck = [hearts, diamonds, clubs,spades ]

deck.sample
  => hearts



diamonds = {"diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"] }
hearts = {"hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"] }
clubs = {"clubs" => [] }
spades = {"spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"] }


def select_card
 suit = SUITS.sample
 "hearts"




deck = {
        "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "clubs" => [],
        "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]
        } 






deck = {
  "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],        
  "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],        
  "clubs" => [],        
  "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]        
}           



suits = ["hearts", "diamonds", "clubs", "spades"]














def suit? suits
  suits.sample
end  

def card_value?(deck, suits)
  deck[suits?].sample
end  

def remove_card! deck, suit, card
  deck[suit].delete(card)
end  

def suit_empty?(suit, deck)
  deck[suit].empty?
end  

def remove_suit(deck, suit)
  deck.delete(suit)
end 


PAINTED_CARD_VALUE = 10

deck = {"diamonds"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "hearts"=>[2, 3, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "clubs"=>[2],
 "spades"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]}

suits = ["hearts", "diamonds", "clubs", "spades"]

suit = "clubs"
=> "clubs"




def deal(suits, deck)

suit = suit? suits
=> "clubs"
suit = clubs



card = card_value? deck, suit
=> 2


remove_card! deck, suit, card
=> 2
deck
=> {"diamonds"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "hearts"=>[2, 3, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "clubs"=>[],
 "spades"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]}




suit_empty? suit, deck
=> true

remove_suit(deck, suit)  if suit_empty? suit, deck
=> []
deck
=> {"diamonds"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "hearts"=>[2, 3, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "spades"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]}





PAINTED_CARD_VALUE = 10



deck = {
        "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "clubs" => [],
        "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]
        } 

suits = ["hearts", "diamonds", "clubs", "spades"]

def deal(suits,deck)
suit = suit? suits
card = card_value? deck, suit
remove_card! deck, suit, card
suit_empty? suits, deck
remove_suit(deck, suits)  if suit_empty? suits, deck
card 
card == Integer ? card : card = PAINTED_CARD_VALUE
[suit,card]
end





card = ace

later assign HARD_ACE or SOFT_ACE

**************************************************************************************************************************************************************************************************

DEAL A CARD 
REMOVE THE DEALT CARD FROM THE DECK 
REMOVE THE SUIT FROM THE DECK IF THE LAST CARD OF THAT SUIT HAS BEEN DEALT
RETURN AN ARRAY WITH THE SUIT AND THE CARD VALUE 
PRINT THE VALUE OF THE CARD TO THE SCREEN
INITIALIZE AN EMPTY PLAYERS HAND 
APPEND THE DEALT CARD TO THE PLAYERS HAND 


PAINTED_CARD_VALUE = 10

def suit? suits
  suits.sample
end  

def card_value?(deck, suits)
  deck[suits].sample
end  

def remove_card! deck, suit, card
  deck[suit].delete(card)
end  

def suit_empty?(suit, deck)
  deck[suit].empty?
end  

def remove_suit(deck, suit)
  deck.delete(suit)
end 

deck = {
        "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "clubs" => [],
        "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]
        } 

suits = ["hearts", "diamonds", "clubs", "spades"]

def deal_card(suits,deck)
  binding.pry
suit = suit? suits
card = card_value? deck, suit
remove_card! deck, suit, card
suit_empty? suit, deck
remove_suit(deck, suits)  if suit_empty? suit, deck
card 
card == Integer ? card : card = PAINTED_CARD_VALUE
[card,suit]
end
# => [ 10, "diamonds"]

dealt_card = deal_card suits, deck
# => [ 10, "diamonds"]

puts "#{dealt_card[0]} of #{dealt_card[1]}"
10 of diamonds



players_hand = []

players_hand << dealt_card

players_hand 
# => [[ 10, "diamonds"]]

**************************************************************************************************************************************************************************************************

Well be using a nested array, where each array element is itself a 2-element 
array that represents the cards suit and the cards value, respectively. 
For example, a hand that contains 2 of Hearts, Jack of Spades, 
and Ace of Diamonds could be represented as a nested array like this:

for ls 

deal_card(suits,deck)
...
[card.to_s,suit]
end
# => [ "10", "diamonds"]

[['H', '2'], ['S', 'J'], ['D', 'A']]

**************************************************************************************************************************************************************************************************


Calculating Aces. Remember that aces can be worth either 1 or 11, depending on the context. 
You should not ask the user what the value of the ace is; your program should be able to 
figure this out automatically

if the player gets an ace that is 11
  then aks for a hit and that is 10 then what
  asks for a hit and the value is 10 then asks for another hit the ace is hard at 1
  asks for a hit at 20 the ace is soft????? 


I am the dealer
in real life when a player gets hit and get an ace as the dealer I dont know what it is until 
  the player wins
  the player busts 
  I win 

  deal a card 

  Ace is soft up to 20
  at 21 the ace is hard 

  ace is soft until the sum of the cards is greater than 10
  5, 5 + ace player wins
  6,5 + ace ace is soft

  ace is hard 1 , up to other cards sum <= 10
  ace is soft 11 after sum of cards is > 10

I need to know the value of the ace so I can calculate the players score


count ace as soft  while the player is asking for a hit until the total of cards is over 21 and the player has not said bust

ace 2,9 21
ace 2 10 not busted hit ace is hard


count ace as soft until 

Soft Hand: Hand with an Ace that doubles as 1 or 11. There is no way you can bust if you hit.

Soft Total: The total of any number of cards in a hand, which includes an Ace which can use it’s 11 value, without exceeding 21. 
  Ex. Hand: Ace, 4. This hand’s Soft Total would be 15. It can also be counted as a Hard 5.



Hard Hand: Hand without an Ace, or with an Ace but only as a value of 1.

Hard Total: The total of any number of cards in a hand, counting Aces as 1.



[hard_ace 1 soft_ace 11]

if ace in players_hand and player hits until  card_values.reduce 
when players_hand.reduce > => 21 and player not bust or wins
    ace = hard
when playershand.reduce > 21 and player bust
  ace is 11

**************************************************************************************************************************************************************************************************
CALCULATE TOTAL


card =["", 'ace']

ACE = 


players_hand = [[ "10", "diamonds"][ "8", "diamonds"]]
dealers_hand

          players_hand
def total(hand)
  # players_hand =  [[ "10", "diamonds"][ "8", "diamonds"]]
  # cards = [['H', '3'], ['S', 'Q'], ... ]
  values = cards.map { |card| card[1] }

  
  sum = 0
  values.each do |value|
    if value == "A" # "ACE"
      sum += 11
    elsif value.to_i == 0 # J, Q, K 
      sum += 10 
    else
      sum += value.to_i
    end
  end

  # correct for Aces
  values.select { |value| value == "A" }.count.times do
    sum -= 10 if sum > 21
  end

  sum
end
=> integer value of player_hand or dealer_hand

players_hand_value = total(players_hand)
dealers_hand_value = total(players_hand)

**************************************************************************************************************************************************************************************************
DETERMINE IF THE PLAYER OR DEALER IS BUSTED


def busted?(hand)
  hand > 21
end


players_hand_value = total(players_hand)
dealers_hand_value = total(players_hand)


players_hand_value = 21
busted? players_hand_value
=> false


players_hand_value = 22
busted? players_hand_value
=> true


**************************************************************************************************************************************************************************************************
PLAYERS TURN 


1. ask "hit" or "stay"
if busted break
2. if "stay", stop asking
3. otherwise, go to #1


def player_turn(suits, deck)

  answer = nil
  loop do
    puts player_hand
    puts players_hand_value
    puts "hit or stay?"
    answer = gets.chomp
    break if answer == 'stay' || busted?(players_hand)   # the busted? method is not shown

  else deal_card(suits, deck)
  end

  if busted?(players_hand)
    # probably end the game? or ask the user to play again?
  else
    puts "You chose to stay!"  # if player didn't bust, must have stayed to get here
  end




players_hand = []

players_hand << dealt_card

players_hand 
# => [[ 10, "diamonds"]]


**************************************************************************************************************************************************************************************************

DALERS TURN 



 break if player busted?(players_hand) || dealer busted?(dealers_hand)
 answer = nil
  loop do
    puts dealers_hand
    puts dealers_hand_value
    puts "hit or stay?"
    answer = gets.chomp
    break if answer == 'stay' || busted?   # the busted? method is not shown

  else deal_card(suits, deck)
  end

  if busted?(dealers_hand)
    # probably end the game? or ask the user to play again?
  else
    puts "You chose to stay!"  # if player didn't bust, must have stayed to get here
  end



dealers_hand = []

dealers_hand << dealt_card

dealers_hand 


final_dealer_value

=> integer 18
=> "busted" .class == String



**************************************************************************************************************************************************************************************************
CALCULATE THE WINNER

player stays
  => 15

dealer stays
  => 18

dealer wins 


player busts  => dealer wins

dealer busts => player wins

who_won? final_dealer_value, final_player_value

def who_won?(dealer,player)
  if dealer == "bust"
    return  "player"
  elsif player == "bust"
    return  "dealer"
  end
  dealer > player? "dealer" : "player"
end


=> "dealer"



**************************************************************************************************************************************************************************************************
DISPLAY WINNER 
  puts whow_won
end


**************************************************************************************************************************************************************************************************
```
CONSIDERATIONS
ou could consider adding some intro e.g. ‘Welcome to the Twenty One game’, and maybe even a brief overview of the rules/ aim of the game.

You are displaying cards that user and dealer have but not suits. It would be better if you could display also the suit of every card user or dealer are holding.

I personally found confusing words stick and twist as I am used to hit and stay.

When I entered TWIST I didn't get new card, so behavior was as if I had decided to stay.

Also, from a user experience it would be nice to allow 1 letter input like s for stick or t for twist.

When I got equal result as a dealer (20) message was that I have won. It should be a tie in that case.

Nice feature to add would be to ask user to play again after the game is finished.

It would be nice to clear the screen after each choice (e.g. after I stick or twist). But before screen is cleared make sure to ask user to press certain key so he could see what card was drawn.

Source code
All displaying logic from lines 104-112 can be separated into different methods. You could have display_player_won method and display_dealer_won method and also display_tie method that you would call in each condition. It adds readability to your code.

Inside of player_turn! method if player_move == 'twist' is producing an error when I enter TWIST as an input.

Overall

When I was asked if I want to see the rules I pressed y and the program didn't show me the rules. From a user experience perspective, it would be better if yes/no (y/n) case insensitive were accepted as valid inputs and every other input should be treated as an error, and error message could be shown.

In other case where you say anything other than no will continue the game it is fine to let user type anything to continue although it would be nice if n was also treated as no.

Finally, when I typed YES program still didn't show me rules, so you might want to make answers case insensitive as I mentioned above.

Similar as above, it would be nice if h and s could be typed instead of hit and stay. Again case insensitive.

When I decided to hit I was shown what card I drew but not the suit of the card. Also, I could see total number of points which is nice, but I couldn't see my other cards. It would be nice if I could see all of my cards all the time, and also dealers card.

When I got 21 program still asked me if I wanted to hit or stay. The game should have ended then as I have won.

You might want to opt to keep overall score on the screen all the time. Also, perhaps it would be good to have some initial message stating the number of rounds required to win the game (while I was playing I didn’t know how many rounds needed to be played).

Source code
Methods ending with ? should return a boolean by convention. Your method does_user_need_rules? displays rules.

Conditional inside of the display_rules method is also unnecessary.

You could refactor these methods a bit. Inside of the does_user_need_rules? method return a boolean true if answer is y or yes case insensitive, otherwise false.

In method display_rules just display rules using prompt.

In method game_greeting you can put display_rules if does_user_need_rules?. I would also change the name of that method to remove does user_needs_rules? is enough and display_rules if user_needs_rules? reads better.

You could also create a method tie? where you would check if the game is a tie and then inside of your increase_game_score method you could put game_score[declare_winner(player, dealer)] += 1 unless tie?. This reads a bit better.

system('clear') || system('cls') would make clear screen work also on Windows systems.

The prompt for hit or stay has a weird behavior. When I enter 'a', the screen clears and I'm asked again if I want to hit or stay. However, it also cleared the value that the dealer got. On the other hand, if I enter 'c', the screen doesn't clear and the dealer's move is still visible. Additionally, I get a message saying that 'c', is invalid.
You only accept "hit" or "stay" as valid inputs. Considering that there will be multiple times I enter either of the values, it might be better to allow single letter inputs (i.e., "h" and "s").
In the prompt for playing another round, it is not clear what value to provide. There is only a question. I type random characters and it led to exiting the game. It would be better if it were clearer what to do. Incidentally, I typed "yes" and the game proceeded to exit.
The game generally plays nicely, with good output/ prompts and input validation (note, the initial message repeats 'wins' -- first one to five wins WINS it All!). I liked the way you dispalyed the cards and score. The UI was easy to understand and interact with.

In a situation where the player busts, there isn't really a need to go on and draw the computer cards (since the computer should automatically win here). You could just say something like 'You busted! Computer wins'.

The game rules state that it's 'first to five', but the game didn't seem to end even after one of the participants had over 5 wins.

Something that might improve the program operation is clearing the screen between cards rather than just between rounds. If a player hits three or four times, you end up with quite a lot of output on the screen.



I like that you've used an array for the deck, though I think hashes might work better for the individual cards. Methods that work with the deck could then reference keys such as card_name: and card_value: instead of using the indices. This would remove the requirement for methods such as card_value, since card_value: would be a piece of data that exists in the card.

You also shouldn't really use a constant here for FRESH_DECK, since you are altering the value of it during program operation. Although the Ruby language doesn't prevent you from changing constants, this is generally considered bad practice. If you encapsualte your cards.each call in a method (e.g. new_deck), you can just assign the return of this method to a local var in the game loop, removing the need for a FRESH_DECK constant.

Methods
I've already spoken a bit about some of your methods in the section on Rubocop. I think generally some of your methods are a bit over-complicated and a little difficult to parse. Some of this stems from your choice of data structure for your cards/ deck, and some of it is down to particular implementation decisions. I think you could definitely simplify things somewhat here. For example, think about what pick_cards! is doing; it generates a random number in order to randomly pick a card, and then has to use delete_at to remove the card using its index. The reason you need to do this is because deck is in a set order and we don't want the cards we pick to be in order. Maybe think if you can approach it from a different direction; the deck of cards is an array, so after initializing the deck, is there some way that we can 'shuffle' the deck? Once it's shuffled, we can just deal from the top each time knowing that we're going to get a random card.

Most of the other methods that I've not mentioned are pretty good (e.g. who_won?, play_again?, etc). They're simple and easy to read, and are focused on doing one specific thing. This is generally what you want to aim for with your methods.

Game Loop
I like the structure of your game loop, and the fact that its basically a set of 'steps' which call the relevant methods. The approach you've gone with of extracting the application logic out of the loop and into the methods is good, I just think that some of the methods themselves need a little more work.

Just to note, line 202 should have system('clear') || system('cls') the same ways as line 189.


One small issue you could address with your code is that the program indicates an answer of 'y' or 'n' is accepted when asking whether the user is ready to play. In reality, the program will accept any input beginning with 'y' or 'n', meaning that 'yellow' will be accepted as 'yes' and 'now' is accepted as no.

I didn't see it ever displayed what the game winning score is. It would be nice to display to the user at the beginning how many round points one must earn to win the game.

After the dealer won the game, the score didn't reset. After the 1st round of my second game, I had 3 points and the dealer had 6.

Source Code
Within the ready method, instead of calling downcase on answer on both lines 41 and 43, you can do so just once when you capture the user input and assign it to answer on line 40.

Your user-input validation in the hit_stay? method is not as strong as it could be. Also, by convention, ending a method name with a question mark (called a 'predicate method') indicates that the method returns a boolean. hit_stay? returns a string.

The result? method also does not return a boolean, it returns a symbol.

The method winner is used solely to display something to the user. I'd recommend reflecting this in the name-- perhaps display_winner.

Unless I'm missing it, I'm not seeing where CARD_VALUES is used in your code. If it isn't used, you should go ahead and remove it.

Overall
Nice job, Bradley. :thumbsup: Review my feedback and try to address some of the issues raised before moving forward.


The UI could be improved with some type of visual indication that a new round has begun. Whether that be clearing the screen, displaying some type of delimiter, etc. As it is, the text displaying the end-of-round information for one round runs right up against the text for the first turn of the next round. It can be a bit difficult to parse.

This a multi-round game where the first player to reach 5 points wins, but that isn't ever really expressed to the user. The score board of overall points updates after each round, but consider including a message informing the user that the game is set up this way at the start of the game so that they know how many points they must reach to win.

The prompt at the end of the game -- 'Do you want to play again?' could give the user an indication of what input is acceptable. I pressed enter/return without entering any input and the game exited. That's perfectly fine, but the prompt could be a bit more clear about what input the program expects.

Source Code
Your display of output on lines 193-199 could be extracted to a method to help clean up your game loop a bit.

You reference 5 several times in your code. Imagine if you later wanted to change the number of points that a player must reach to win the game. Or that someone else reading your code must determine what the number's significance is. For improved readability and easier maintenance, I recommend using a constant instead like you did with WINNING_VALUE and DEALER_CAP.

Consider whether lines 244-245 could be extracted into a method called something like reset_scores.

Regarding the number of parameters for update_score. Generally you do want to try to avoid writing methods that require many parameters. But always consider the tradeoffs. If you find yourself consistently defining methods with more than a couple of parameters, consider whether you're in the habit of having your methods are doing too much. I think most of your methods are well-written. update_score doesn't only update the score, however, as it also calculates the winner, which requires you to pass in player_total and dealer_total. You could instead initialize winner outside of this method (maybe in the game loop) and then pass winner in to update_score instead of player_total and dealer_total. This updated version of your method would then have a very singular purpose-- to update the score.

Your program doesn't have strong user-input validation when asking the user whether they would like to hit or stay. I entered no input, and it interpreted as 'stay'. I see this same behavior when asked whether I would like to play again. I suggest trying to implement some stronger user-input validation here for some extra practice.

I like that you display the current scores of the player and dealer at the end of each round. One suggestion is to display how many points it takes to become the 'grand winner' as part of your opening display message. As it is currently, that is unknown to the user until someone has already hit 5 points and a grand winner message is displayed.

Source Code
Don't forget to remove debugging code like require 'pry' when you're finished with it.

I would advise assigning 21, 17, and 5 to constants and referencing the constants throughout your code instead, rather than using these 'magic numbers' in your logic. To someone else reading through your code (or your future self), it might not be immediately obvious what these numbers represent. Also, if you were to make changes to the game in the future (let's say you decide want the computer to hit until they reach a minimum of 18 points instead of 17 or change how many rounds must be won to become the grand winner), you would then only need to update this value at one place in your code.

In check_for_winner, you should be able to assign winner to the return value of the if statement, rather placing the assignment in all five branches of the if statement. Like so:
```ruby

 ____
| 10 |
|    |
| Q  |
|____|








