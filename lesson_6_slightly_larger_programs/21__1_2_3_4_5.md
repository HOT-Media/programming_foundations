1. Initialize deck
2. Deal cards to player and dealer
3. Player turn: hit or stay
  - repeat until bust or "stay"
4. If player bust, dealer wins.
5. Dealer turn: hit or stay
  - repeat until total >= 17
6. If dealer bust, player wins.
7. Compare cards and declare winner.


HARD_ACE = 1
ACE = HARD_ACE + 10


Soft Hand: Hand with an Ace that doubles as 1 or 11. There is no way you can bust if you hit.
def soft_hand? 


Soft Total: The total of any number of cards in a hand, which includes an Ace which can use it’s 11 value, without exceeding 21. 
  - Ex. Hand: Ace, 4. This hand’s Soft Total would be 15. It can also be counted as a Hard 5.


soft_total =

Bust: When a player’s or dealer’s hand exceeds 21.
BUST = 

Bust Card: The individual card that results in the player’s or dealer’s hand going over 21.
bust_card = 


Hard Hand: Hand without an Ace, or with an Ace but only as a value of 1.
hand_value = 10
=> 10
HARD_HAND = HARD_ACE + hand_value
=> 11
HARD_HAND
=> 11



Hard Total: The total of any number of cards in a hand, counting Aces as 1.
HARD_TOTAL = card_value + HARD_ACE

Hit: This playing decision will require the dealer to deal another card onto the player’s Blackjack hand.
def hit(caution - user might be dealer or player)

Natural (blackjack hand): A player who receives an Ace and a 10-point card as the initial two cards on a deal is said to have a “natural 21” or a “blackjack”. Depending on the house rules, this hand is usually awarded 3:2 on the player’s bet. I.e. Player bets $10 and is paid $15.
def nautural? 


Round: In Blackjack, a Round starts with no cards on the table, and the player’s bets being placed. A hand is dealt to every player, and the dealer, and the Round ends when those hands have been played through, and the player’s bets have been paid out.
ROUND = 

Stand / stay : This playing decision will refuse the dealer from dealing another card onto the player’s Blackjack hand.
stand = break

Cut Card: A plastic card used to cut the deck after shuffling. The dealer reshuffles the deck after reaching the cut card when dealing hands.
CUT_CARD = 

Dealer - the casino employee, facing the players, who deals the cards at the table.

DEALER = 



 deal Hand - the original cards dealt to each player.
original_hand

Push - a tie between the dealer and the player, no one wins or loses.
def push? 


Shuffle - mixing up the cards before dealing them.
def shuffle!

Stiff Card - a card ranked from 2 to 6, which may force the dealer to hit.
STIFF_CARD = 

Stiff Hand - any hand totalling 12-16, which will bust on a 10-value card hit.
def stiff_hand?

Ten-Value Card - any card worth 10 points, a 10, Jack, Queen, or King.
TEN_VALUE_CARD


Upcard - the dealer's exposed card, seen by all players.
upcard = 

downcard = 

Face Cards: Face Cards are cards which have pictures on them. These include jacks, queens and kings. In each deck of cards, you’ll find that there are 4 of each present.
starting number of face cards
jacks = 4 = jack - 1 
king = 4
queen = 4

JACK = 10
KING = 10
QUEEN = 10




Standing Hand: A ‘standing hand’ is one in which the player has a total hand value of 17 and higher. In this case, it is not considered wise to take another card.
STANDING_HAND = value >= 17
def standing_hand? 

Stiff Hand: A ‘stiff hand’ is a hand which is not ranked as a great hand. Typically, the total score of the hand in this case is quite low, so you in hindsight the player does not have much of a chance to winning. Nonetheless, if the player chooses to hit, he/she might bust as a result.
STIFF_HAND = hand_value > 9


deck start with a normal 52-card deck consisting of the 4 suits (hearts, diamonds, clubs, and spades), and 13 values (2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king, ace).
can a constant be = the values of other constants
deck = 52 or deck = jacks + kings + queens


dealer \
          later they will probablly make the game switch choose who is the dealer
player /











When you display the results, you also need to perform the calculation of who won. Having one method that does both the calculation and the display to the output makes it hard to reason about. The trick is to create a method that only returns the result of the game, and another that only handles displaying the result. You want to write methods that only do one thing.






1. Initialize deck
2. Deal cards to player and dealer
3. Player turn: hit or stay
  - repeat until bust or "stay"
4. If player bust, dealer wins.
5. Dealer turn: hit or stay
  - repeat until total >= 17
6. If dealer bust, player wins.
7. Compare cards and declare winner.



Figure out a data structure to contain the "deck" and the "player's cards" and "dealer's cards". Maybe a hash? An array? A nested array? Your decision will have consequences throughout your code, but don't be afraid of choosing the wrong one. Play around with an idea, and see how far you can push it. If it doesn't work, back out of it.

You start with a normal 52-card deck consisting of the 4 suits (hearts, diamonds, clubs, and spades), and 13 values (2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king, ace).

```ruby

deck 
  - starts with 52 cards
    - 4 jacks
    - 4 kings
    - 4 queens

jack = 10
king = 10
queen = 10
ace = 1


hearts, diamonds, clubs, and spades)
deck ={ hearts => [2,3,4,5,6,7,8,9,10, jack, king, queen, ace]   } 

deck[hearts][two]
=> 2

hearts = [2,3,4,5,6,7,8,9,10, jack, king, queen, ace]


deck -=  dealt_card heart[jack] => 10
                    heart[king] => 10
                    heart[face_value] => 4 

iterate through deck.sample

dealer_hand += dealt_card

player_hand += dealt_card



display the players deck

display the dealers first card

deal

King 
Ace of Hearts: 

2 of Hearts: 

3 of Hearts: 

4 of Hearts: 

5 of Hearts: 

6 of Hearts: 

7 of Hearts:

8 of Hearts: 
9 of Hearts: 

10 of Hearts: 

Jack of Hearts: 

Queen of Hearts: 

King of Hearts: 



5 of Hearts
2 of Hearts:



SUITS = ["hearts", "diamonds", "clubs", "spades" ]
suit_values = [2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king, ace]

deck = [hearts, diamonds, clubs,spades ]

deck.sample
  => hearts



diamonds = {"diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"] }
hearts = {"hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"] }
clubs = {"clubs" => [] }
spades = {"spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"] }


def select_card
 suit = SUITS.sample
 "hearts"




deck = {
        "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "clubs" => [],
        "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]
        } 






deck = {
  "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],        
  "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],        
  "clubs" => [],        
  "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]        
}           



suits = ["hearts", "diamonds", "clubs", "spades"]














def suit? suits
  suits.sample
end  

def card_value?(deck, suits)
  deck[suits?].sample
end  

def remove_card! deck, suit, card
  deck[suit].delete(card)
end  

def suit_empty?(suit, deck)
  deck[suit].empty?
end  

def remove_suit(deck, suit)
  deck.delete(suit)
end 


PAINTED_CARD_VALUE = 10

deck = {"diamonds"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "hearts"=>[2, 3, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "clubs"=>[2],
 "spades"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]}

suits = ["hearts", "diamonds", "clubs", "spades"]

suit = "clubs"
=> "clubs"




def deal(suits, deck)

suit = suit? suits
=> "clubs"
suit = clubs



card = card_value? deck, suit
=> 2


remove_card! deck, suit, card
=> 2
deck
=> {"diamonds"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "hearts"=>[2, 3, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "clubs"=>[],
 "spades"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]}




suit_empty? suit, deck
=> true

remove_suit(deck, suit)  if suit_empty? suit, deck
=> []
deck
=> {"diamonds"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "hearts"=>[2, 3, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
 "spades"=>[2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]}





PAINTED_CARD_VALUE = 10



deck = {
        "diamonds" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "hearts" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"],
        "clubs" => [],
        "spades" => [2, 3, 4, 5, 6, 7, 8, 9, 10, "jack", "queen", "king", "ace"]
        } 

suits = ["hearts", "diamonds", "clubs", "spades"]

def deal(suits,deck)
suit = suit? suits
card = card_value? deck, suit
remove_card! deck, suit, card
suit_empty? suits, deck
remove_suit(deck, suits)  if suit_empty? suits, deck
card 
card == Integer ? card : card = PAINTED_CARD_VALUE
[suit,card]
end





card = ace

later assign HARD_ACE or SOFT_ACE

****************************************************************************************************

SUITS = ["Hearts", "Diamonds", "Clubs", "Spades"]
FACE_CARDS = ["Jack", "King", "Queen", "Ace"]
NUMBERED_CARDS = 1.upto(10){|number| cards << number}

deck = []
SUITS.each do |suit|
  deck

["Hearts", "Diamonds", "Clubs", "Spades"]


deck = {
        "Diamonds" => [],
        "Hearts" => [],
        "Clubs" => [],
        "Spades" => []
        } 


Iterate through the deck key value pairs and add numbers and FACE_CARDS to each key 

deck["diamonds"] = NUMBERED_CARDS
deck["diamonds"] [array] << 1..10 << FACE_CARDS



FACE_CARDS = ["Jack", "King", "Queen", "Ace"]
NUMBERED_CARDS = 1.upto(10){|num| Array.new << num}


deck = {
        "Diamonds" => [],
        "Hearts" => [],
        "Clubs" => [],
        "Spades" => []
        } 


cards = {}

deck.each_key do |suit|
  # cards[suit] = NUMBERED_CARDS
  cards[suit] << 1.upto(10){|num| cards[suit] << num}

  #cards[suit] = NUMBERED_CARDS << FACE_CARDS
end

deck = {
        "Diamonds" => [],
        "Hearts" => [],
        "Clubs" => [],
        "Spades" => []
        } 

cards = {}

deck.each_key do |key|
  1.upto(10){|num| cards[key] << num}
  # FACE_CARDS = ["Jack", "King", "Queen", "Ace"]
  #FACE_CARDS.each{|suit| cards[key] << suit }
end
cards






1.upto(10){|num| cards["Diamonds"] << num}
=> 1
cards
=> {"Diamonds"=>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
 "Hearts"=>1,
 "Clubs"=>1,
 "Spades"=>1}






key[]

deck.each do |key






cards = []
=> []
1.upto(10){|num| cards << num}
=> 1
cards
=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
SUITS = ["Hearts", "Diamonds", "Clubs", "Spades"]
=> ["Hearts", "Diamonds", "Clubs", "Spades"]
SUITS[0..3]
=> ["Hearts", "Diamonds", "Clubs", "Spades"]
SUITS[0]
=> "Hearts"
SUITS.each{|suit| cards << suit}
=> ["Hearts", "Diamonds", "Clubs", "Spades"]
cards
=> [1,
 2,
 3,
 4,
 5,
 6,
 7,
 8,
 9,
 10,
 "Hearts",
 "Diamonds",
 "Clubs",
 "Spades"]







**********************************************************************************************
**********************************************************************************************

def subprocess_deal
end


**********************************************************************************************
**********************************************************************************************



**********************************************************************************************
**********************************************************************************************


Well be using a nested array, where each array element is itself a 2-element 
array that represents the cards suit and the cards value, respectively. 
For example, a hand that contains 2 of Hearts, Jack of Spades, 
and Ace of Diamonds could be represented as a nested array like this:

for ls 

deal_card(suits,deck)
...
[card.to_s,suit]
end
# => [ "10", "diamonds"]

[['H', '2'], ['S', 'J'], ['D', 'A']]

**************************************************************************************************************************************************************************************************


Calculating Aces. Remember that aces can be worth either 1 or 11, depending on the context. 
You should not ask the user what the value of the ace is; your program should be able to 
figure this out automatically

if the player gets an ace that is 11
  then aks for a hit and that is 10 then what
  asks for a hit and the value is 10 then asks for another hit the ace is hard at 1
  asks for a hit at 20 the ace is soft????? 


I am the dealer
in real life when a player gets hit and get an ace as the dealer I dont know what it is until 
  the player wins
  the player busts 
  I win 

  deal a card 

  Ace is soft up to 20
  at 21 the ace is hard 

  ace is soft until the sum of the cards is greater than 10
  5, 5 + ace player wins
  6,5 + ace ace is soft

  ace is hard 1 , up to other cards sum <= 10
  ace is soft 11 after sum of cards is > 10

I need to know the value of the ace so I can calculate the players score


count ace as soft  while the player is asking for a hit until the total of cards is over 21 and the player has not said bust

ace 2,9 21
ace 2 10 not busted hit ace is hard


count ace as soft until 

Soft Hand: Hand with an Ace that doubles as 1 or 11. There is no way you can bust if you hit.

Soft Total: The total of any number of cards in a hand, which includes an Ace which can use it’s 11 value, without exceeding 21. 
  Ex. Hand: Ace, 4. This hand’s Soft Total would be 15. It can also be counted as a Hard 5.



Hard Hand: Hand without an Ace, or with an Ace but only as a value of 1.

Hard Total: The total of any number of cards in a hand, counting Aces as 1.



[hard_ace 1 soft_ace 11]

if ace in players_hand and player hits until  card_values.reduce 
when players_hand.reduce > => 21 and player not bust or wins
    ace = hard
when playershand.reduce > 21 and player bust
  ace is 11

**************************************************************************************************************************************************************************************************
CALCULATE TOTAL

def calculate_total_md
end

players_hand = [["D", "K"], ["H", "4"]]

          players_hand
def total(hand)
  values = cards.map { |card| card[1] }
  sum = 0
  values.each do |value|
    if value == "A" # "ACE"
      sum += 11
    elsif value.to_i == 0 # J, Q, K 
      sum += 10 
    else
      sum += value.to_i
    end
  end
  # correct for Aces
  values.select { |value| value == "A" }.count.times do
    sum -= 10 if sum > 21
  end
  sum
end


=> integer value of player_hand or dealer_hand

players_hand_value = total(players_hand)
dealers_hand_value = total(players_hand)

**************************************************************************************************************************************************************************************************
DETERMINE IF THE PLAYER OR DEALER IS BUSTED


def busted?(hand)
  hand > 21
end


players_hand_value = total(players_hand)
dealers_hand_value = total(players_hand)


players_hand_value = 21
busted? players_hand_value
=> false


players_hand_value = 22
busted? players_hand_value
=> true



**********************************************************************************************
**********************************************************************************************




MY GAMEPLAY 

WINNING_SCORE = 5


link -> deck 

player_hand = []
dealer_hand = []

player_score = 0
dealer_score = 0



def display_rules # => press enter to start the game
 display_game_score # points for each round

loop do # break when the player or dealer score is 5, WINNING_SCORE = 5 

  loop do # player hand and dealer hand loop
# maybe def first_deal player, dealer => deal cards, return hands and deck
    deal # to player
    deal # to player
    deal # to dealer card up
    display_hands# card with question mark for dealer + 1 card up 
    calculate_hand_values # calculate using calculate_withou_downcard
      players_hand_value = calculate_hand_values(players_hand)

      dealers_downcard_hand(dealers_hand) # during players turn
      dealers_hand_value = calculate_hand_values(calculate_without_downcard)

    display_hand_values # display players full hand value and dealers upcard value


    loop do # players hand
    twenty_one? => false
#   player_twenty_one? => true
# def display_twenty_one => "!! TWENTY ONE !!"
#   display_hand_values  # player 21 dealer 
# break players hand loop 
    hit? => true
    deal # another card to player
    display_hands
    calculate_hand_values
    display_hand_values
    twenty_one? => false
    bust? => false
    hit? => # Yes No Y N y n else prompt for valid input => N => false players_hand_value = 18
    break # players hand loop
  end # players hand loop

SCENARIO: PLAYER BUST DURING THE PLAYERS TURN
#   hit? # Y => 
#   deal
#   display_hands
#   calculate_hand_values
#   display_hand_values
#   player_21? => false
#   busted? # => true players_hand_value = 25
# def display_bust # puts "!!! Player Bust !!! "

# loop do  # dealer hand loop
#   display_hands  # reveal down card
#   calculate_hand_values # dealers total hand value
#   display_hand_values # display values for player 25 and dealers hand value 
# def someone_won_hand? => bust? or push? # player bust? => true
# def who_won_hand? => dealer
# def display_hand_winner # => "Dealer"
# def keep_score => dealer_score += 1
# def display_score # player 0 dealer 1
# def someone_won_game? => false
# loop back to player hand and dealer hand loop

SCENARIO: DEALER WINS GAME AFTER PLAYER BUSTS  
# def someone_won_game? => true
# def who_won_game? => dealer
# def display_game_winner => Dealer won the game
# def play_again? => true  Yes No Y N y n 
# Y => loop back to # break when the player or dealer score is 5, WINNING_SCORE = 5
# N => break player or dealer score loop 
  # end player or dealer score loop
# puts "Thanks for playing"
# end # program



SCENARIO: PLAYER STAY AT 18
  loop do # dealers hand
   dealer_reveal_downcard(dealers_hand)
   display_hands # players hand and show dealers full hand
   calculate_hand_values
   players_hand_value = calculate_hand_values(players_hand)
   dealer_reveal_downcard(dealers_hand)
   dealers_hand_value = calculate_hand_values(dealers_hand)
    display_hand_values # with dealers hand added in now
    twenty_one? # => false
    hit? # => true
    deal # another card to dealer
    display_hands 
    calculate_hand_values
    display_hand_values
    dealer_push? => false
    twenty_one? => false
    bust? => false
    hit? => true
    deal # another card to dealer
    display_hand_values # with dealers hand added in now
    twenty_one? => false
    hit? => true
    deal # another card to dealer
    display_hands 
    calculate_hand_values
    display_hand_values
    dealer_push? => false
    twenty_one? => false
    bust? => false
    hit? => false
    break # dealers hand loop

SCENARIO: DEALER WON THE HAND - NEITHER PLAYER NOR DEALER WON THE GAME
  display_hand_values # player 18 dealer 20
  who_won_hand? #=> Dealer 
  display_hand_winner
  add_one_point #=> dealer # += 1  player 0   dealer 1
  display_game_score # always displayed, now updated with the final score of the player 0 dealer 1
  someone_won_game? # false
  # loop back to player hand and dealer hand loop




SCENARIO: DEALER WON WITH 5 POINTS
  display_hand_values # player 18 dealer 20
  who_won_hand? # => Dealer
  display_hand_winner 
  add_one_point # => # dealer += 1  player 0   dealer 5
  display_game_score # always displayed, now updated with the final score of the player 0 dealer 5
  someone_won_game? # => true
  
  break # first to 5 loop
  who_won_game? #=> dealer
  display_game_winner 
  play_again? => false
  break
end


SCENARIO: PLAY AGAIN - YES
play_again? => true Yes No Y N yes no y n 
loop back to break when the player or dealer score is 5, WINNING_SCORE = 5 






**********************************************************************************************
**********************************************************************************************


DALERS TURN 

hit until 17 then bust if over 21

 break if player busted?(players_hand) || dealer busted?(dealers_hand)
 answer = nil
  loop do
    puts dealers_hand
    puts dealers_hand_value
    puts "hit or stay?"
    answer = gets.chomp
    break if answer == 'stay' || busted?   # the busted? method is not shown

  else deal_card(suits, deck)
  end

  if busted?(dealers_hand)
    # probably end the game? or ask the user to play again?
  else
    puts "You chose to stay!"  # if player didn't bust, must have stayed to get here
  end



dealers_hand = []

dealers_hand << dealt_card

dealers_hand 


final_dealer_value

=> integer 18
=> "busted" .class == String



**************************************************************************************************************************************************************************************************
CALCULATE THE WINNER

player stays
  => 15

dealer stays
  => 18

dealer wins 


player busts  => dealer wins

dealer busts => player wins

who_won? final_dealer_value, final_player_value

def who_won?(dealer,player)
  if dealer == "bust"
    return  "player"
  elsif player == "bust"
    return  "dealer"
  end
  dealer > player? "dealer" : "player"
end


=> "dealer"



**************************************************************************************************************************************************************************************************
DISPLAY WINNER 
  puts whow_won
end


**************************************************************************************************************************************************************************************************
WINNING_SCORE = 5


GAMEPLAY

loop do # play again loop 
  players_hand = []
  dealers_hand = []
  loop do # until player or dealer wins 
    players_hand << deal_card
    display players hand
    dealers_hand << deal_card
    display dealers card 
    players_hand << deal_card
    display players hand
    dealers_hand << deal_card
    display dealers_hand first card up second card down 

    def players turn
    until bust or stay

    def dealers turn until bust or stay

    who won round
    record score of who won

    break if 
    someone_won_game
    # => true
 def play_again
  # => false
  break if play_again == false






no player turn method 
stack methods inside a loop then break at stand or bust








































you could consider adding some intro e.g. ‘Welcome to the Twenty One game’, and maybe even a brief overview of the rules/ aim of the game.

It would be nice to clear the screen after each choice (e.g. after I stick or twist). But before screen is cleared make sure to ask user to press certain key so he could see what card was drawn.

All displaying logic from lines 104-112 can be separated into different methods. You could have display_player_won method and display_dealer_won method and also display_tie method that you would call in each condition. It adds readability to your code.



```
CONSIDERATIONS
ou could consider adding some intro e.g. ‘Welcome to the Twenty One game’, and maybe even a brief overview of the rules/ aim of the game.

You are displaying cards that user and dealer have but not suits. It would be better if you could display also the suit of every card user or dealer are holding.

I personally found confusing words stick and twist as I am used to hit and stay.

When I entered TWIST I didn't get new card, so behavior was as if I had decided to stay.

Also, from a user experience it would be nice to allow 1 letter input like s for stick or t for twist.

When I got equal result as a dealer (20) message was that I have won. It should be a tie in that case.

Nice feature to add would be to ask user to play again after the game is finished.

It would be nice to clear the screen after each choice (e.g. after I stick or twist). But before screen is cleared make sure to ask user to press certain key so he could see what card was drawn.

Source code
All displaying logic from lines 104-112 can be separated into different methods. You could have display_player_won method and display_dealer_won method and also display_tie method that you would call in each condition. It adds readability to your code.

Inside of player_turn! method if player_move == 'twist' is producing an error when I enter TWIST as an input.

Overall

When I was asked if I want to see the rules I pressed y and the program didn't show me the rules. From a user experience perspective, it would be better if yes/no (y/n) case insensitive were accepted as valid inputs and every other input should be treated as an error, and error message could be shown.

In other case where you say anything other than no will continue the game it is fine to let user type anything to continue although it would be nice if n was also treated as no.

Finally, when I typed YES program still didn't show me rules, so you might want to make answers case insensitive as I mentioned above.

Similar as above, it would be nice if h and s could be typed instead of hit and stay. Again case insensitive.

When I decided to hit I was shown what card I drew but not the suit of the card. Also, I could see total number of points which is nice, but I couldn't see my other cards. It would be nice if I could see all of my cards all the time, and also dealers card.

When I got 21 program still asked me if I wanted to hit or stay. The game should have ended then as I have won.

You might want to opt to keep overall score on the screen all the time. Also, perhaps it would be good to have some initial message stating the number of rounds required to win the game (while I was playing I didn’t know how many rounds needed to be played).

Source code
Methods ending with ? should return a boolean by convention. Your method does_user_need_rules? displays rules.

Conditional inside of the display_rules method is also unnecessary.

You could refactor these methods a bit. Inside of the does_user_need_rules? method return a boolean true if answer is y or yes case insensitive, otherwise false.

In method display_rules just display rules using prompt.

In method game_greeting you can put display_rules if does_user_need_rules?. I would also change the name of that method to remove does user_needs_rules? is enough and display_rules if user_needs_rules? reads better.

You could also create a method tie? where you would check if the game is a tie and then inside of your increase_game_score method you could put game_score[declare_winner(player, dealer)] += 1 unless tie?. This reads a bit better.

system('clear') || system('cls') would make clear screen work also on Windows systems.

The prompt for hit or stay has a weird behavior. When I enter 'a', the screen clears and I'm asked again if I want to hit or stay. However, it also cleared the value that the dealer got. On the other hand, if I enter 'c', the screen doesn't clear and the dealer's move is still visible. Additionally, I get a message saying that 'c', is invalid.
You only accept "hit" or "stay" as valid inputs. Considering that there will be multiple times I enter either of the values, it might be better to allow single letter inputs (i.e., "h" and "s").
In the prompt for playing another round, it is not clear what value to provide. There is only a question. I type random characters and it led to exiting the game. It would be better if it were clearer what to do. Incidentally, I typed "yes" and the game proceeded to exit.
The game generally plays nicely, with good output/ prompts and input validation (note, the initial message repeats 'wins' -- first one to five wins WINS it All!). I liked the way you dispalyed the cards and score. The UI was easy to understand and interact with.

In a situation where the player busts, there isn't really a need to go on and draw the computer cards (since the computer should automatically win here). You could just say something like 'You busted! Computer wins'.

The game rules state that it's 'first to five', but the game didn't seem to end even after one of the participants had over 5 wins.

Something that might improve the program operation is clearing the screen between cards rather than just between rounds. If a player hits three or four times, you end up with quite a lot of output on the screen.



I like that you've used an array for the deck, though I think hashes might work better for the individual cards. Methods that work with the deck could then reference keys such as card_name: and card_value: instead of using the indices. This would remove the requirement for methods such as card_value, since card_value: would be a piece of data that exists in the card.

You also shouldn't really use a constant here for FRESH_DECK, since you are altering the value of it during program operation. Although the Ruby language doesn't prevent you from changing constants, this is generally considered bad practice. If you encapsualte your cards.each call in a method (e.g. new_deck), you can just assign the return of this method to a local var in the game loop, removing the need for a FRESH_DECK constant.

Methods
I've already spoken a bit about some of your methods in the section on Rubocop. I think generally some of your methods are a bit over-complicated and a little difficult to parse. Some of this stems from your choice of data structure for your cards/ deck, and some of it is down to particular implementation decisions. I think you could definitely simplify things somewhat here. For example, think about what pick_cards! is doing; it generates a random number in order to randomly pick a card, and then has to use delete_at to remove the card using its index. The reason you need to do this is because deck is in a set order and we don't want the cards we pick to be in order. Maybe think if you can approach it from a different direction; the deck of cards is an array, so after initializing the deck, is there some way that we can 'shuffle' the deck? Once it's shuffled, we can just deal from the top each time knowing that we're going to get a random card.

Most of the other methods that I've not mentioned are pretty good (e.g. who_won?, play_again?, etc). They're simple and easy to read, and are focused on doing one specific thing. This is generally what you want to aim for with your methods.

Game Loop
I like the structure of your game loop, and the fact that its basically a set of 'steps' which call the relevant methods. The approach you've gone with of extracting the application logic out of the loop and into the methods is good, I just think that some of the methods themselves need a little more work.

Just to note, line 202 should have system('clear') || system('cls') the same ways as line 189.


One small issue you could address with your code is that the program indicates an answer of 'y' or 'n' is accepted when asking whether the user is ready to play. In reality, the program will accept any input beginning with 'y' or 'n', meaning that 'yellow' will be accepted as 'yes' and 'now' is accepted as no.

I didn't see it ever displayed what the game winning score is. It would be nice to display to the user at the beginning how many round points one must earn to win the game.

After the dealer won the game, the score didn't reset. After the 1st round of my second game, I had 3 points and the dealer had 6.

Source Code
Within the ready method, instead of calling downcase on answer on both lines 41 and 43, you can do so just once when you capture the user input and assign it to answer on line 40.

Your user-input validation in the hit_stay? method is not as strong as it could be. Also, by convention, ending a method name with a question mark (called a 'predicate method') indicates that the method returns a boolean. hit_stay? returns a string.

The result? method also does not return a boolean, it returns a symbol.

The method winner is used solely to display something to the user. I'd recommend reflecting this in the name-- perhaps display_winner.

Unless I'm missing it, I'm not seeing where CARD_VALUES is used in your code. If it isn't used, you should go ahead and remove it.

Overall
Nice job, Bradley. :thumbsup: Review my feedback and try to address some of the issues raised before moving forward.


The UI could be improved with some type of visual indication that a new round has begun. Whether that be clearing the screen, displaying some type of delimiter, etc. As it is, the text displaying the end-of-round information for one round runs right up against the text for the first turn of the next round. It can be a bit difficult to parse.

This a multi-round game where the first player to reach 5 points wins, but that isn't ever really expressed to the user. The score board of overall points updates after each round, but consider including a message informing the user that the game is set up this way at the start of the game so that they know how many points they must reach to win.

The prompt at the end of the game -- 'Do you want to play again?' could give the user an indication of what input is acceptable. I pressed enter/return without entering any input and the game exited. That's perfectly fine, but the prompt could be a bit more clear about what input the program expects.

Source Code
Your display of output on lines 193-199 could be extracted to a method to help clean up your game loop a bit.

You reference 5 several times in your code. Imagine if you later wanted to change the number of points that a player must reach to win the game. Or that someone else reading your code must determine what the number's significance is. For improved readability and easier maintenance, I recommend using a constant instead like you did with WINNING_VALUE and DEALER_CAP.

Consider whether lines 244-245 could be extracted into a method called something like reset_scores.

Regarding the number of parameters for update_score. Generally you do want to try to avoid writing methods that require many parameters. But always consider the tradeoffs. If you find yourself consistently defining methods with more than a couple of parameters, consider whether you're in the habit of having your methods are doing too much. I think most of your methods are well-written. update_score doesn't only update the score, however, as it also calculates the winner, which requires you to pass in player_total and dealer_total. You could instead initialize winner outside of this method (maybe in the game loop) and then pass winner in to update_score instead of player_total and dealer_total. This updated version of your method would then have a very singular purpose-- to update the score.

Your program doesn't have strong user-input validation when asking the user whether they would like to hit or stay. I entered no input, and it interpreted as 'stay'. I see this same behavior when asked whether I would like to play again. I suggest trying to implement some stronger user-input validation here for some extra practice.

I like that you display the current scores of the player and dealer at the end of each round. One suggestion is to display how many points it takes to become the 'grand winner' as part of your opening display message. As it is currently, that is unknown to the user until someone has already hit 5 points and a grand winner message is displayed.

Source Code
Don't forget to remove debugging code like require 'pry' when you're finished with it.

I would advise assigning 21, 17, and 5 to constants and referencing the constants throughout your code instead, rather than using these 'magic numbers' in your logic. To someone else reading through your code (or your future self), it might not be immediately obvious what these numbers represent. Also, if you were to make changes to the game in the future (let's say you decide want the computer to hit until they reach a minimum of 18 points instead of 17 or change how many rounds must be won to become the grand winner), you would then only need to update this value at one place in your code.

In check_for_winner, you should be able to assign winner to the return value of the if statement, rather placing the assignment in all five branches of the if statement. Like so:
```ruby



players_cards_graphics
first_line = ''
second_line = ''
third_line = ''
fourth_line = ''
fifth_line = ''

dealcard

def construct_card(suit,value)
" ____ " << " ____ "
"| #{suit} |" << "| 10 |"
"|    |" << "|    |"
"| #{value}  |" << "| Q  |"
"|____|" << "|____|"
end


****************************************************************************************************************************************************************

MY CONSTRUCT CARD METHOD

use a local variable insisde the construct_card method  representing each line of a new card, 
for each card dealt, append one of each constant to the symbol
:first_line :second_line etc and construct another card line by
line  so the end result is a string, with each line of the card appended to
the previous card so a string of first lines then on the next line a string 
the secondlines



CONSTRUCTING A CARD 
A hash is used as the data set initially containg a key for each horizontal 
line of a card and a value which is an empty string.

players_hand = {
                first_line: "",
                second_line:  "",
                third_line: "",
                fourth_line: "",
                fifth_line: ""
               }
when a card is dealt, another horizontal "section" of each card is appended << to each line
because the players_hand is a hash, players_hand can be passed into the construct_method.
the values, strings, can be mutated and are available outside the construct_card method

these strings are appended resepectively:
first_line = " ____ "
  second_line = "| #{value}  |"
  third_line = "|    |"
  fourth_line = "| #{suit}  |"
  fifth_line = "|____|"

players_hand[:first_line] << first_line
  players_hand[:second_line] << second_line
  players_hand[:third_line] << third_line
  players_hand[:fourth_line] << fourth_line
  players_hand[:fifth_line] << fifth_line

CARD DISPLAY 
when the card is displayed, the players_hand keys are puts to the screen
A new horizontal section is << each time a card is dealt so the appended string displays the mutated string.






players_hand = {
                first_line: "",
                second_line:  "",
                third_line: "",
                fourth_line: "",
                fifth_line: ""
               }


def construct_card(players_hand, suit, value)
  first_line = " ____ "
  second_line = "| #{value}  |"
  third_line = "|    |"
  fourth_line = "| #{suit}  |"
  fifth_line = "|____|"
  updated_hand = {}
  players_hand[:first_line] << first_line
  players_hand[:second_line] << second_line
  players_hand[:third_line] << third_line
  players_hand[:fourth_line] << fourth_line
  players_hand[:fifth_line] << fifth_line
end

def display_card updated_hand # hash 
  puts updated_hand[:first_line]
  puts  updated_hand[:second_line]
  puts  updated_hand[:third_line]
  puts  updated_hand[:fourth_line]
  puts  updated_hand[:fifth_line]
end


suit = "H"
value = "9"

construct_card(players_hand, suit, value)

players_hand

display_card players_hand # hash 

suit = "D"
value = "8"

construct_card(players_hand, suit, value)

display_card players_hand


suit = "C"
value = "A"

construct_card(players_hand, suit, value)

display_card players_hand



players_hand = {
  first_line: "",                
  second_line:  "",                
  third_line: "",                
  fourth_line: "",                
  fifth_line: ""                
}                 
=> {:first_line=>"", :second_line=>"", :third_line=>"", :fourth_line=>"", :fifth_line=>""}


def construct_card(players_hand, suit, value)
  first_line = " ____ "  
  second_line = "| #{value}  |"  
  third_line = "|    |"  
  fourth_line = "| #{suit}  |"  
  fifth_line = "|____|"  
  updated_hand = {}  
  players_hand[:first_line] << first_line  
  players_hand[:second_line] << second_line  
  players_hand[:third_line] << third_line  
  players_hand[:fourth_line] << fourth_line  
  players_hand[:fifth_line] << fifth_line  
end  
=> :construct_card

def display_card updated_hand # hash 
  puts updated_hand[:first_line]  
  puts  updated_hand[:second_line]  
  puts  updated_hand[:third_line]  
  puts  updated_hand[:fourth_line]  
  puts  updated_hand[:fifth_line]  
end  
=> :display_card


suit = "H"
=> "H"
value = "9"
=> "9"
construct_card(players_hand, suit, value)
=> "|____|"

players_hand
=> {:first_line=>" ____ ", :second_line=>"| 9  |", :third_line=>"|    |", :fourth_line=>"| H  |", :fifth_line=>"|____|"}
display_card players_hand # hash 
 ____ 
| 9  |
|    |
| H  |
|____|
=> nil
suit = "D"
=> "D"
value = "8"
=> "8"

construct_card(players_hand, suit, value)
=> "|____||____|"

display_card players_hand
 ____  ____ 
| 9  || 8  |
|    ||    |
| H  || D  |
|____||____|
=> nil
suit = "C"
=> "C"
value = "A"
=> "A"

construct_card(players_hand, suit, value)
=> "|____||____||____|"

display_card players_hand
 ____  ____  ____ 
| 9  || 8  || A  |
|    ||    ||    |
| H  || D  || C  |
|____||____||____|
=> nil




****************************************************************************************************************************************************************
MY GAME PLAY LOOP 



RULES = list of rules and game play 

HELP = copied strategies from the web

WINNING_HANDS = 5

loop do until someone wins 5 hands 

  loop do play one hand loop 
  deal?
  deal to player
    display player card 
  dealers_first_card? => true
  dealers_down_card!
  deal to player
    display player cards # 2
  deal to dealer
    display dealer card
    display player hand score
    display dealer upcard score
  record dealer score

    loop do
      player hand 10,2
      player_21? => false
      player hit? => true
        hit player 4
          player_has_ace? => false
          calculate player total
        player bust?=> false
          display player hand 10,2,4
          display player total 16
      player_hit? => true
        hit player 4
        player_has_ace? => false
        calculate player total
          display player hand 10,2,4,4
          display player total 20
        hitplayer? => false
   end

   loop do 
    player_21? => false
    player_bust? => false
    display dealers hand k,6
      dealer_has_ace? => false
      calculate dealers score
        display dealers score 16
      dealer_bust? => false
      dealer_under_seventeen? => true
      dealer hit 3
        display dealer hand k,6,3
        dealer_has_ace? => false
        calculate dealer score 
        display dealer score 19
      dealer_under_seventeen? => false
      dealer bust? => false
      dealer_stay
  end 

    who has the highest score? => player => 20
    display player won that hand
  end play hand loop
  player += 1 if player won the hand
  computer += 1 if the dealer won the hand

  player or dealer win 5? true
  break until 5 loop

  play again
   y n yes, no

  break play again loop if n or no 
  play again if y or yes
  validate input 
  only y n yes or no
end
















****************************************************************************************************
REFERENCE 


first_line = " ____ "
second_line = "| #{suit}  |"
third_line = "|    |"
fourth_line = "| D  |"
fifth_line = "|____|"




def construct_card(players_hand, suit, value)
  first_line = " ____ "
  second_line = "| #{value}  |"
  third_line = "|    |"
  fourth_line = "| #{suit}  |"
  fifth_line = "|____|"
  updated_hand = {}
  players_hand[:first_line] << first_line
  players_hand[:second_line] << second_line
  players_hand[:third_line] << third_line
  players_hand[:fourth_line] << fourth_line
  players_hand[:fifth_line] << fifth_line
end


def display_card updated_hand # hash 
  puts updated_hand[:first_line]
  puts  updated_hand[:second_line]
  puts  updated_hand[:third_line]
  puts  updated_hand[:fourth_line]
  puts  updated_hand[:fifth_line]
end


suit = "H"
value = "10"
players_hand
=> {:first_line=>"", :second_line=>"", :third_line=>"", :fourth_line=>"", :fifth_line=>""}
construct_card players_hand, suit, value
=> "|____|"
players_hand
=> {:first_line=>" ____ ", :second_line=>"| K  |", :third_line=>"|    |", :fourth_line=>"| D  |", :fifth_line=>"|____|"}
puts display_card players_hand
 ____ 
|2   |
|    |
| D  |
|____|

=> nil
construct_card players_hand, suit, value
=> "|____||____|"
puts display_card players_hand
 ____  ____ 
| K  || K  |
|     ||    |
| D  || D  |
|____||____|

=> nil
construct_card players_hand, suit, value
=> "|____||____||____|"
puts display_card players_hand
 ____  ____  ____ 
| K  || K  || K  |
|    ||    ||    |
| D  || D  || D  |
|____||____||____|

=> nil
construct_card players_hand, suit, value
=> "|____||____||____||____|"
puts display_card players_hand
 ____  ____  ____  ____ 
| K  || K  || K  || K  |
|    ||    ||    ||    |
| D  || D  || D  || D  |
|____||____||____||____|

=> nil

first_line = " ____   ____   ____    ____   ____   ____   ____    ____"
second_line = "| 10 | | 10 | | 10 |  | 10 | | 10 | | 10 | | 10 |  | 10 |"
third_line = "|    | |    | |    |  |    | |    | |    | |    |  |    |"
fourth_line = "| Q  | | Q  | | Q  |  | Q  | | 10 | | 10 | | 10 |  | 10 |"
fifth_line = "|____| |____| |____|  |____| |____| |____| |____|  |____|"
def card
  first_line = " ____   ____   ____    ____   ____   ____   ____    ____"
second_line = "| 10 | | 10 | | 10 |  | 10 | | 10 | | 10 | | 10 |  | 10 |"
third_line = "|    | |    | |    |  |    | |    | |    | |    |  |    |"
fourth_line = "| Q  | | Q  | | Q  |  | Q  | | 10 | | 10 | | 10 |  | 10 |"
fifth_line = "|____| |____| |____|  |____| |____| |____| |____|  |____|"
  puts first_line
  puts second_line
  puts third_line
  puts fourth_line
  puts fifth_line
end

def card
  first_line = " ____   ____   ____    ____   ____   ____   ____    ____"  
  second_line = "| 10 | | 10 | | 10 |  | 10 | | 10 | | 10 | | 10 |  | 10 |"
  third_line = "|    | |    | |    |  |    | |    | |    | |    |  |    |"
  fourth_line = "| Q  | | Q  | | Q  |  | Q  | | 10 | | 10 | | 10 |  | 10 |"
  fifth_line = "|____| |____| |____|  |____| |____| |____| |____|  |____|"
  puts first_line  
  puts second_line  
  puts third_line  
  puts fourth_line  
  puts fifth_line  
end  
=> :card
card
 ____   ____   ____    ____   ____   ____   ____    ____
| 10 | | 10 | | 10 |  | 10 | | 10 | | 10 | | 10 |  | 10 |
|    | |    | |    |  |    | |    | |    | |    |  |    |
| Q  | | Q  | | Q  |  | Q  | | 10 | | 10 | | 10 |  | 10 |
|____| |____| |____|  |____| |____| |____| |____|  |____|












 ____   ____   ____    ____   ____   ____   ____    ____
| 10 | | 10 | | 10 |  | 10 | | 10 | | 10 | | 10 |  | 10 |
|    | |    | |    |  |    | |    | |    | |    |  |    |
| Q  | | Q  | | Q  |  | Q  | | Q  | | Q  | | Q  |  | Q  |
|____| |____| |____|  |____| |____| |____| |____|  |____|

 ____  <<  ____
| 10 | << | 10 |
|    | << |    |
| Q  | << | Q  |
|____| << |____|


def construct_card(suit,value)
" ____ " << " ____ "
"| #{suit} |" << "| 10 |"
"|    |" << "|    |"
"| #{value}  |" << "| Q  |"
"|____|" << "|____|"
end



















































